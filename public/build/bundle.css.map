{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">// NOTE: yes, I know this file looks intimidating and is terrible for web devs\r\n// at the moment lol - I'll get to moving things around into their own component files\r\n// a little later. I was just focused on basic functionality and getting things\r\n// out there for now.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport marked, { Slugger } from 'marked';\r\nimport hotable from 'handsontable';\r\nimport { onMount, tick } from 'svelte';\r\n// https://www.30secondsofcode.org/blog/s/copy-text-to-clipboard-with-javascript\r\nconst copyToClipboard = str => {\r\n    const el = document.createElement('textarea');\r\n    el.value = str;\r\n    el.setAttribute('readonly', '');\r\n    el.style.position = 'absolute';\r\n    el.style.left = '-9999px';\r\n    document.body.appendChild(el);\r\n    el.select();\r\n    document.execCommand('copy');\r\n    document.body.removeChild(el);\r\n};\r\nhotable.renderers.registerRenderer(\"hex\", (instance, td, row, col, prop, value, cellProperties) => {\r\n    td.style.fontFamily = \"monospace\";\r\n    td.style.fontWeight = \"bold\";\r\n    td.style.textAlign = \"center\";\r\n    if (typeof value === \"string\") {\r\n        td.innerText = \"0x\" + (value.startsWith(\"0x\") ? parseInt(value, 16) : parseInt(value)).toString(16).toUpperCase();\r\n    }\r\n    else if (typeof value === \"number\") {\r\n        td.innerText = \"0x\" + value.toString(16).toUpperCase();\r\n    }\r\n    else {\r\n        td.innerText = \"NaN\";\r\n    }\r\n    return td;\r\n});\r\nconst tables = [];\r\nlet TOC = [];\r\nconst renderer = {\r\n    // @ts-ignore\r\n    code(code, language, isEscaped) {\r\n        if (language !== \"handsontable\") {\r\n            return false;\r\n        }\r\n        const HOTConfig = {\r\n            nestedHeaders: [[]],\r\n            data: [],\r\n            columns: [],\r\n            manualColumnResize: true,\r\n            licenseKey: \"non-commercial-and-evaluation\",\r\n            mergeCells: [],\r\n            height: 'auto',\r\n            readOnly: true,\r\n            modifyColWidth: (width, col) => {\r\n                if (width > 400) {\r\n                    return 400;\r\n                }\r\n                return width;\r\n            }\r\n        };\r\n        // determines what to do and when\r\n        let parseMode = null;\r\n        let currentOptions = {};\r\n        let currentCol = 0;\r\n        let headingGroupPath = [];\r\n        let matchCurrentCol = () => {\r\n            for (const [idx, col] of HOTConfig.nestedHeaders.entries()) {\r\n                if (headingGroupPath[idx]) {\r\n                    headingGroupPath[idx].colspan++;\r\n                }\r\n                else {\r\n                    const currLen = col.reduce((acc, curr) => acc + (([\"undefined\", \"string\"].includes(typeof curr)) ? 1 : curr.colspan), 0);\r\n                    if (currentCol > currLen)\r\n                        col.push(...new Array(currentCol - currLen));\r\n                }\r\n            }\r\n        };\r\n        for (const line of code.split(\"\\n\")) {\r\n            if (line.startsWith(\"# OPTIONS\")) {\r\n                parseMode = \"options\";\r\n                continue;\r\n            }\r\n            else if (line.startsWith(\"# COLUMNS\")) {\r\n                parseMode = \"columns\";\r\n                continue;\r\n            }\r\n            else if (line.startsWith(\"# DATA\")) {\r\n                parseMode = \"data\";\r\n                continue;\r\n            }\r\n            switch (parseMode) {\r\n                case \"options\": {\r\n                    const options = line.split(\":\").map(v => v.trim());\r\n                    if ([\"true\", \"false\"].includes(options[1]))\r\n                        HOTConfig[options[0]] = (options[1] === \"true\") ? true : false;\r\n                    else\r\n                        HOTConfig[options[0]] = options[1];\r\n                    continue;\r\n                }\r\n                case \"columns.options\": {\r\n                    if (line.trim() === \"}\") {\r\n                        HOTConfig.columns.push(currentOptions);\r\n                        currentOptions = {};\r\n                        parseMode = \"columns\";\r\n                        continue;\r\n                    }\r\n                    const options = line.split(\":\").map(v => v.trim());\r\n                    if ([\"true\", \"false\"].includes(options[1]))\r\n                        currentOptions[options[0]] = (options[1] === \"true\") ? true : false;\r\n                    else\r\n                        currentOptions[options[0]] = options[1];\r\n                    continue;\r\n                }\r\n                case \"columns\": {\r\n                    if (line.endsWith(\"[\")) {\r\n                        headingGroupPath.push({ label: line.substr(0, line.length - 2).trim(), colspan: 0 });\r\n                        if (HOTConfig.nestedHeaders.length <= headingGroupPath.length) {\r\n                            const newHeaderRow = [];\r\n                            if (currentCol > 0)\r\n                                newHeaderRow.push(...new Array(currentCol));\r\n                            HOTConfig.nestedHeaders.push(newHeaderRow);\r\n                        }\r\n                    }\r\n                    else if (line.trim() === \"]\") {\r\n                        const newData = headingGroupPath.pop();\r\n                        HOTConfig.nestedHeaders[headingGroupPath.length].push(newData);\r\n                        // console.log(\"in-progress:\", JSON.parse(JSON.stringify(HOTConfig.nestedHeaders)));\r\n                    }\r\n                    else if (line.endsWith(\"{\")) {\r\n                        HOTConfig.nestedHeaders[headingGroupPath.length].push(line.substr(0, line.length - 2).trim());\r\n                        parseMode = \"columns.options\";\r\n                        currentCol++;\r\n                        matchCurrentCol();\r\n                    }\r\n                    else {\r\n                        HOTConfig.columns.push({});\r\n                        HOTConfig.nestedHeaders[headingGroupPath.length].push(line.trim());\r\n                        currentCol++;\r\n                        matchCurrentCol();\r\n                    }\r\n                    continue;\r\n                }\r\n                case \"data\": {\r\n                    const rowData = line.split(\"|\").map(d => d.trim().replace(/\\\\n/g, \"\\n\"));\r\n                    const reg = /^<\\$(?:w(?<width>\\d+))?\\s?(?:h(?<height>\\d+))?\\s?(?:s\"(?<styling>.+?)\")?\\>/gm;\r\n                    for (const [col, d] of rowData.entries()) {\r\n                        const results = reg.exec(d);\r\n                        if (!results)\r\n                            continue;\r\n                        if (results.groups.height || results.groups.width) {\r\n                            const cellHeight = parseInt(results.groups.height) || 1;\r\n                            const cellWidth = parseInt(results.groups.width) || 1;\r\n                            const row = HOTConfig.data.length;\r\n                            HOTConfig.mergeCells.push({\r\n                                col,\r\n                                row,\r\n                                colspan: cellWidth,\r\n                                rowspan: cellHeight\r\n                            });\r\n                        }\r\n                        rowData[col] = rowData[col].substring(results[0].length);\r\n                    }\r\n                    HOTConfig.data.push(rowData);\r\n                    continue;\r\n                }\r\n                default:\r\n                    continue;\r\n            }\r\n        }\r\n        // HOTConfig.nestedHeaders.reverse();\r\n        // if (HOTConfig.nestedHeaders.length > 1) console.log(HOTConfig.nestedHeaders);\r\n        const outHTML = `<div id=\"HOTable-${tables.length}\"></div>`;\r\n        tables.push(HOTConfig);\r\n        return outHTML;\r\n    },\r\n    // @ts-ignore\r\n    heading(text, level, raw, slugger) {\r\n        // @ts-ignore\r\n        TOC = [...TOC, { text: raw, level, id: slugger.slug(raw, { dryrun: true }) }];\r\n        return false;\r\n    },\r\n    // @ts-ignore\r\n    link(href, title, text) {\r\n        if (href.startsWith(\"/\")) {\r\n            // @ts-ignore\r\n            return `<a href=\"${window.location.origin}?page=${href.substring(1, href.indexOf(\"#\"))}&location=${new Slugger().slug(href.substr(href.indexOf(\"#\")), { dryrun: true })}\">${text}</a>`;\r\n        }\r\n        else if (href.startsWith(\"#\")) {\r\n            // @ts-ignore\r\n            return `<a href=\"${window.location.origin}?page=${localStorage.getItem(\"lastPage\")}&location=${new Slugger().slug(href.substr(1), { dryrun: true })}\">${text}</a>`;\r\n        }\r\n        else if (href.includes(\"localhost\") || href.includes(\"brawlre.github.io\")) {\r\n            return `<a href=\"${window.location.origin}/${href.replace(/https?:\\/\\/(?:localhost:\\d{4}|brawlre\\.github\\.io)/g, \"\")}\">${text}</a>`;\r\n        }\r\n        return false;\r\n    }\r\n};\r\nmarked.use({ renderer });\r\nconst serializeHOTable = (htable) => {\r\n    const data = htable.getData();\r\n    const headingData = htable.getSettings().nestedHeaders;\r\n    const mergedCells = htable.getSettings().mergeCells;\r\n    const columnData = htable.getSettings().columns;\r\n    const optionData = Object.entries(Object.getPrototypeOf(htable.getSettings()));\r\n    console.log(columnData);\r\n    const modified = {};\r\n    for (const [name, value] of optionData) {\r\n        if (typeof value === \"boolean\" && value !== hotable.DefaultSettings[name])\r\n            modified[name] = value;\r\n    }\r\n    delete modified.contextMenu;\r\n    delete modified.manualColumnResize;\r\n    let out = \"```handsontable\\n\";\r\n    out += \"# OPTIONS\\n\";\r\n    for (const [option, value] of Object.entries(modified)) {\r\n        out += `${option}: ${value}\\n`;\r\n    }\r\n    out += \"# COLUMNS\\n\";\r\n    const indexesTraversed = new Array(headingData.length).fill(0);\r\n    const traverseTableHeadings = (layer, parentLength) => {\r\n        let idx = indexesTraversed[layer];\r\n        let currentTraversal = 0;\r\n        while (idx < headingData[layer].length && ![\"string\", \"object\"].includes(typeof headingData[layer][idx])) {\r\n            idx++;\r\n        }\r\n        while (currentTraversal < parentLength && idx < headingData[layer].length) {\r\n            if (typeof headingData[layer][idx] === \"object\") {\r\n                out += `${\"\".padStart(layer * 2, \" \")}${headingData[layer][idx].label} [\\n`;\r\n                traverseTableHeadings(layer + 1, headingData[layer][idx].colspan);\r\n                currentTraversal += headingData[layer][idx].colspan;\r\n            }\r\n            else if (typeof headingData[layer][idx] === \"string\") {\r\n                out += `${\"\".padStart(layer * 2, \" \")}${headingData[layer][idx]}`;\r\n                let currHeadingPos = 0;\r\n                for (let i = 0; i < idx; i++) {\r\n                    currHeadingPos += ([\"undefined\", \"string\"].includes(typeof headingData[layer][i])) ? 1 : headingData[layer][i].colspan;\r\n                }\r\n                if (Object.keys(columnData[currHeadingPos]).length > 0) {\r\n                    out += \" {\\n\";\r\n                    for (const [key, val] of Object.entries(columnData[currentTraversal])) {\r\n                        out += `${\"\".padStart((layer + 1) * 2, \" \")}${key}: ${val}\\n`;\r\n                    }\r\n                    out += `${\"\".padStart(layer * 2, \" \")}}\\n`;\r\n                }\r\n                else {\r\n                    out += \"\\n\";\r\n                }\r\n                currentTraversal += 1;\r\n            }\r\n            else {\r\n                currentTraversal += 1;\r\n            }\r\n            idx++;\r\n        }\r\n        if (layer !== 0)\r\n            out += `${\"\".padStart((layer - 1) * 2, \" \")}]\\n`;\r\n        indexesTraversed[layer] = idx;\r\n    };\r\n    traverseTableHeadings(0, headingData[0].reduce((acc, curr) => acc + (([\"undefined\", \"string\"].includes(typeof curr)) ? 1 : curr.colspan), 0));\r\n    out += \"# DATA\\n\";\r\n    for (const merged of mergedCells) {\r\n        data[merged.row][merged.col] = `<$w${merged.colspan}h${merged.rowspan}>` + data[merged.row][merged.col];\r\n    }\r\n    for (let i = 0; i < data.length; i++) {\r\n        data[i] = data[i].join(\"|\").replace(/\\r?\\n/g, \"\\\\n\");\r\n    }\r\n    out += data.join(\"\\n\");\r\n    out += \"\\n```\";\r\n    return out;\r\n};\r\nlet markedHTMLOut = \"\";\r\nconst updatePageContent = (contentName) => __awaiter(void 0, void 0, void 0, function* () {\r\n    localStorage.setItem(\"lastPage\", contentName);\r\n    tables.length = 0;\r\n    TOC.length = 0;\r\n    if (window.location.hostname === \"localhost\")\r\n        markedHTMLOut = marked((yield (yield fetch(\"./docs/\" + contentName + \".md\")).text()));\r\n    else\r\n        markedHTMLOut = marked((yield (yield fetch(\"https://raw.githubusercontent.com/BrawlRE/BrawlRE.github.io/main/public/docs/\" + contentName + \".md\")).text()));\r\n    yield tick();\r\n    if (tables.length > 10) {\r\n        for (const [idx, tableConfig] of tables.entries()) {\r\n            const renderBtn = document.createElement(\"button\");\r\n            renderBtn.innerText = \"show table\";\r\n            renderBtn.onclick = () => {\r\n                const tableBaseEl = document.getElementById(`HOTable-${idx}`);\r\n                tableBaseEl.innerHTML = \"\";\r\n                const tableToggleButton = document.createElement(\"button\");\r\n                tableToggleButton.innerText = \"hide table\";\r\n                const tableEditCopyButton = document.createElement(\"button\");\r\n                tableEditCopyButton.innerText = \"edit table\";\r\n                const tableDisplayEl = document.createElement(\"div\");\r\n                tableToggleButton.onclick = () => {\r\n                    tableToggleButton.innerText = ((tableDisplayEl.style.display === \"none\") ? \"hide\" : \"show\") + \" table\";\r\n                    tableEditCopyButton.style.display = (tableDisplayEl.style.display === \"none\") ? \"inline-block\" : \"none\";\r\n                    tableDisplayEl.style.display = (tableDisplayEl.style.display === \"none\") ? \"inline-block\" : \"none\";\r\n                };\r\n                tableBaseEl.appendChild(tableToggleButton);\r\n                tableBaseEl.appendChild(tableEditCopyButton);\r\n                tableBaseEl.appendChild(tableDisplayEl);\r\n                const htable = new hotable(tableDisplayEl, tableConfig);\r\n                tableEditCopyButton.onclick = () => {\r\n                    htable.updateSettings({\r\n                        readOnly: false,\r\n                        contextMenu: true,\r\n                        allowInsertColumn: true,\r\n                        allowInsertRow: true,\r\n                    });\r\n                    tableEditCopyButton.innerText = \"copy as markdown\";\r\n                    tableEditCopyButton.onclick = () => {\r\n                        copyToClipboard(serializeHOTable(htable));\r\n                    };\r\n                };\r\n            };\r\n            document.getElementById(`HOTable-${idx}`).appendChild(renderBtn);\r\n        }\r\n    }\r\n    else {\r\n        for (const [idx, tableConfig] of tables.entries()) {\r\n            const tableBaseEl = document.getElementById(`HOTable-${idx}`);\r\n            const tableToggleButton = document.createElement(\"button\");\r\n            tableToggleButton.innerText = \"hide table\";\r\n            const tableEditCopyButton = document.createElement(\"button\");\r\n            tableEditCopyButton.innerText = \"edit table\";\r\n            const tableDisplayEl = document.createElement(\"div\");\r\n            tableToggleButton.onclick = () => {\r\n                tableToggleButton.innerText = ((tableDisplayEl.style.display === \"none\") ? \"hide\" : \"show\") + \" table\";\r\n                tableEditCopyButton.style.display = (tableDisplayEl.style.display === \"none\") ? \"inline-block\" : \"none\";\r\n                tableDisplayEl.style.display = (tableDisplayEl.style.display === \"none\") ? \"inline-block\" : \"none\";\r\n            };\r\n            tableBaseEl.appendChild(tableToggleButton);\r\n            tableBaseEl.appendChild(tableEditCopyButton);\r\n            tableBaseEl.appendChild(tableDisplayEl);\r\n            const htable = new hotable(tableDisplayEl, tableConfig);\r\n            tableEditCopyButton.onclick = () => {\r\n                htable.updateSettings({\r\n                    readOnly: false,\r\n                    contextMenu: true,\r\n                    allowInsertColumn: true,\r\n                    allowInsertRow: true,\r\n                });\r\n                tableEditCopyButton.innerText = \"copy as markdown\";\r\n                tableEditCopyButton.onclick = () => {\r\n                    copyToClipboard(serializeHOTable(htable));\r\n                };\r\n            };\r\n        }\r\n    }\r\n    for (const heading of document.querySelectorAll(\"h1, h2, h3, h4, h5, h6\")) {\r\n        heading.addEventListener(\"click\", () => {\r\n            copyToClipboard(`${window.location.origin}?page=${contentName}&location=${heading.id}`);\r\n        });\r\n    }\r\n});\r\n(() => __awaiter(void 0, void 0, void 0, function* () {\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    const linkedPage = urlParams.get('page');\r\n    const linkedLocation = urlParams.get('location');\r\n    yield updatePageContent(linkedPage || localStorage.getItem(\"lastPage\") || \"index\");\r\n    // @ts-ignore\r\n    if (linkedLocation)\r\n        document.getElementById(new marked.Slugger().slug(linkedLocation, { dryrun: true })).scrollIntoView();\r\n}))();\r\n// incredibly basic implementation - easy to break BUT ALSO very intuitive to use\r\nlet pages = [];\r\n(() => __awaiter(void 0, void 0, void 0, function* () {\r\n    const indentSize = 2;\r\n    let pageDataLines;\r\n    if (window.location.hostname === \"localhost\")\r\n        pageDataLines = (yield (yield fetch(\"./docs/_pages.txt\")).text()).replace(/\\r/g, \"\").split(\"\\n\");\r\n    else\r\n        pageDataLines = (yield (yield fetch(\"https://raw.githubusercontent.com/BrawlRE/BrawlRE.github.io/main/public/docs/_pages.txt\")).text()).replace(/\\r/g, \"\").split(\"\\n\");\r\n    const pathStack = [];\r\n    let lastIndentLevel = 0;\r\n    for (const line of pageDataLines) {\r\n        const thisIndentLevel = line.search(/\\S/);\r\n        if (thisIndentLevel < lastIndentLevel) {\r\n            const levels = (lastIndentLevel - thisIndentLevel) / indentSize;\r\n            for (let i = 0; i < levels; i++)\r\n                pathStack.pop();\r\n            lastIndentLevel = thisIndentLevel;\r\n        }\r\n        else {\r\n            lastIndentLevel = thisIndentLevel;\r\n        }\r\n        pages = [...pages, pathStack.join('') + line.trim()];\r\n        if (line.endsWith(\"/\")) {\r\n            pathStack.push(line.trim());\r\n            lastIndentLevel += 2;\r\n        }\r\n    }\r\n}))();\r\n</script>\n\n<!-- svelte-ignore a11y-no-onchange -->\n\n\n<main>\n  <div class=\"sidebar\">\n    <div class=\"list\">\n      {#each pages as page}\n        {#if page.endsWith(\"/\")}\n        <div\n          class=\"nav-dir-header\"\n          style=\"margin-left: {(page.split('/').length - 2) * 10}px\"\n        >\n          <span>{page.split(\"/\")[page.split(\"/\").length - 2] + \"/\"}</span>\n        </div>\n        {:else}\n          <div\n            class=\"nav-link\"\n            on:click={() => updatePageContent(page)}\n            style=\"margin-left: {(page.split('/').length - 1) * 10}px\"\n          >\n            {page.split(\"/\")[page.split(\"/\").length - 1]}\n          </div>\n        {/if}\n      {/each}\n    </div>\n  </div>\n  <div class=\"content\">\n      {@html markedHTMLOut}\n  </div>\n  <div class=\"TOC\">\n    <ul>\n      {#each TOC as header}\n        <li style=\"margin-left: {(header.level - 1) * 10}px\"><a href=\"#{header.id}\">{header.text}</a></li>\n      {/each}\n    </ul>\n  </div>\n</main>\n\n<style>\nmain {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-content: center;\n}\n\nmain > .sidebar {\n  width: 250px;\n  height: 100vh;\n  box-shadow: inset -2px 0 2px #0004;\n  flex-shrink: 0;\n  overflow-y: scroll;\n}\n\nmain > .sidebar::-webkit-scrollbar {\n  display: none;\n}\n\nmain > .sidebar > .list {\n  width: 100%;\n  padding: 20px;\n  font-size: 16px;\n}\n\n.list > .nav-dir-header {\n  font-weight: bold;\n  margin-bottom: 5px;\n}\n.list > .nav-link:hover {\n  background-color: #0001;\n  cursor: pointer;\n}\n\nmain > .content {\n  min-width: 500px;\n  height: 100vh;\n  padding: 10px 20px;\n  overflow-y: scroll;\n  overflow-x: scroll;\n  flex-grow: 1;\n}\n\nmain > .content::-webkit-scrollbar {\n  display: none;\n}\n\n:global(.wtHider) {\n  /* idk why but it breaks without this extremly hacky solution :( */\n  height: initial !important;\n}\n\nmain > .TOC > ul {\n  box-shadow: inset 2px 0 2px #0004;\n\n  padding: 20px;\n  margin: 0;\n  width: 200px;\n  list-style: none;\n  height: 100vh;\n  overflow-y: scroll;\n\n  flex-shrink: 0;\n}\n\nmain > .TOC > ul > li {\n  margin: 0;\n}\n\n:global(h1:hover, h2:hover, h3:hover, h4:hover, h5:hover, h6:hover) {\n  cursor: pointer;\n  text-shadow: 0 1px 3px #0004;\n}\n\n:global(h1:hover::before, h2:hover::before, h3:hover::before, h4:hover::before, h5:hover::before, h6:hover::before) {\n  content: \"🔗\";\n  display: inline;\n  /* position: inline; */\n  /* right: 100%;\n  margin: auto; */\n}\n\n@media only screen and (max-width: 1000px) {\n  main > .sidebar {\n    display: none;\n  }\n\n  main > .TOC {\n    display: none;\n  }\n}\n</style>"
  ],
  "names": [],
  "mappings": "AAwbA,IAAI,4DAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,aAAa,CAAE,MAAM,AACvB,CAAC,AAED,mBAAI,CAAG,QAAQ,6CAAC,CAAC,AACf,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAClC,WAAW,CAAE,CAAC,CACd,UAAU,CAAE,MAAM,AACpB,CAAC,AAED,mBAAI,CAAG,qDAAQ,mBAAmB,AAAC,CAAC,AAClC,OAAO,CAAE,IAAI,AACf,CAAC,AAED,mBAAI,CAAG,uBAAQ,CAAG,KAAK,8BAAC,CAAC,AACvB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,AACjB,CAAC,AAED,oBAAK,CAAG,eAAe,6CAAC,CAAC,AACvB,WAAW,CAAE,IAAI,CACjB,aAAa,CAAE,GAAG,AACpB,CAAC,AACD,oBAAK,CAAG,sDAAS,MAAM,AAAC,CAAC,AACvB,gBAAgB,CAAE,KAAK,CACvB,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,mBAAI,CAAG,QAAQ,6CAAC,CAAC,AACf,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,CAAC,AACd,CAAC,AAED,mBAAI,CAAG,qDAAQ,mBAAmB,AAAC,CAAC,AAClC,OAAO,CAAE,IAAI,AACf,CAAC,AAEO,QAAQ,AAAE,CAAC,AAEjB,MAAM,CAAE,OAAO,CAAC,UAAU,AAC5B,CAAC,AAED,mBAAI,CAAG,mBAAI,CAAG,EAAE,8BAAC,CAAC,AAChB,UAAU,CAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAEjC,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,CAAC,CACT,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,IAAI,CAChB,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,MAAM,CAElB,WAAW,CAAE,CAAC,AAChB,CAAC,AAED,mBAAI,CAAG,mBAAI,CAAG,iBAAE,CAAG,EAAE,eAAC,CAAC,AACrB,MAAM,CAAE,CAAC,AACX,CAAC,AAEO,0DAA0D,AAAE,CAAC,AACnE,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,AAC9B,CAAC,AAEO,0GAA0G,AAAE,CAAC,AACnH,OAAO,CAAE,IAAI,CACb,OAAO,CAAE,MAAM,AAIjB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,mBAAI,CAAG,QAAQ,6CAAC,CAAC,AACf,OAAO,CAAE,IAAI,AACf,CAAC,AAED,mBAAI,CAAG,IAAI,6CAAC,CAAC,AACX,OAAO,CAAE,IAAI,AACf,CAAC,AACH,CAAC"
}